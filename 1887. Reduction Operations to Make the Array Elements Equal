Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:

Find the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.
Find the next largest value in nums strictly smaller than largest. Let its value be nextLargest.
Reduce nums[i] to nextLargest.
Return the number of operations to make all elements in nums equal.

Input: nums = [5,1,3]
Output: 3
Explanation: It takes 3 operations to make all elements in nums equal:
1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [3,1,3].
2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [1,1,3].
3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1].


apporch
At first we have to convert 5 to 4, now frequency of 4 become freq[4] + freq[5]
now we have convert all 4 to 3, now frequency of 3 become freq[3] + freq[4] + freq[5]
now we have convert all 3 to 2, now frequency of 2 become freq[2] + freq[3] + freq[4] + freq[5]
this freq[2] will be converted into 1 and this will our final answer.

1, 2, 3, 4, 4, 5 -> freq[5] = 1
1, 2, 3, 4, 4, 4 -> freq[4] = 2 + (1), ans = 1
1, 2, 3, 3, 3, 3 -> freq[3] = 1 + (2 + 1), ans = 4
1, 2, 2, 2, 2, 2 -> freq[2] = 1 + (1 + 2 + 1), ans = 8
1, 1, 1, 1, 1, 1 -> freq[1] = 1 + (1 + 2 + 1 + 1), ans = 13
ans = 13


 int reductionOperations(vector<int>& nums) {
        int n=nums.size();
       map<int,int>m;
        for(int i=0;i<n;i++)
        {
            m[nums[i]]++;
        }
        int ans=0;
        int prev=0;
        for(auto it=m.end();it!=m.begin();it--)
        {
            ans+=it->second+prev;
            prev+=it->second;
        }

        return ans;


    }
